#!/bin/bash

set +eu

LIST_FILE="${DFLINK_YAML:-"${XDG_DATA_HOME:-"${HOME}"/.local/share}"/dflist/dflist.yml}"
DF_ROOT=${DFLINK_DOTFILES_ROOT:-""${HOME}"/.dflink"}
DF_ROOT=${DF_ROOT%/}

# Show command usage
show_usage() {
    echo "Usage: $0 {add|rm} [-r] [package] [dirctory(default: '.')] [file|directory]"
    echo "  add: Add a file or directory to the list"
    echo "      -r: Recursive operation (for directories)"
    echo "  rm: Remove a file or directory from the list"
    echo "      -r: Recursive operation (for directories)"
    echo "  show: Show lnlist.yaml."
    echo "  edit: Edit lnlist.yaml. (Use \$EDITOR)"
    echo "  help: Show help."
    echo "  [package]: Name of the package"
    echo "  [file|directory]: Full path to the file or directory"
    echo "Example: $0 add bash ~/.bash_history"
    echo "         $0 add -r vim ~/.vim"
}

# Escape special charactors
escape_special_chars() {
    echo "$1" | sed 's/[]\/$*.^[]/\\&/g'
}

# Transform arg path to absolute_path
to_absolute_path() {
    local path="$1"
    if [[ "$path" != /* ]]; then
        path="$(cd "$(dirname "$path")" || exit; pwd)/$(basename "$path")"
    fi
    echo "$path"
}

# Convert home directory to ${HOME}
convert_home_dir_to_home_env() {
    local directory="$1"
    echo "${directory/#$HOME/\${HOME\}}"
}

# Convert ${HOME} to home directory
convert_home_env_to_home_dir() {
    local directory="$1"
    echo "${directory/#\${HOME\}/$HOME}"
}

# Add file
add() {
    local package="$1"
    local directory="$2"
    local file="$3"

    # IF file not exists
    if [ ! -f "$file" ]; then
        echo "File not exists: $file"
        return
    fi

    file=$(to_absolute_path "$file")
    # echo "$package, $directory, $file" && exit

    local target_dir
    target_dir=$(dirname "$file")
    local filename
    filename=$(basename "$file")

    target_dir=$(convert_home_dir_to_home_env "$target_dir")

    local dup_pkgs
    dup_pkgs="$(yq ".packages[].directories[].files[] | select(.target_dir == \"$target_dir\" and .name == \"$filename\") | parent(4) | .name" "$LIST_FILE")"
    if [ "$dup_pkgs" != '' ]; then
        echo "File already exists: $target_dir/$filename"
        echo "Containing Library: ${dup_pkgs//$'\n'/, }"
        return
    fi

    # Check package
    local package_index
    package_index="$(yq ".packages | to_entries[] | select(.value.name == \"$package\") | key" "$LIST_FILE")"

    if [ "$package_index" = '' ]; then
        # New package
        package_index="$(yq '.packages | length' "$LIST_FILE")"
        yq -i ".packages[$package_index].name = \"$package\"" "$LIST_FILE"
    fi

    # Check directory
    local dir_index
    dir_index="$(yq ".packages[$package_index].directories | to_entries[] | select(.value.path == \"$directory\") | key" "$LIST_FILE")"
    local dir_length
    dir_length="$(yq ".packages[$package_index].directories | length" "$LIST_FILE")"

    if [ "$dir_index" = '' ]; then
        # New directory
        dir_index="$dir_length"
        yq -i ".packages[$package_index].directories[$dir_index].path = \"$directory\"" "$LIST_FILE"
    fi

    # Check file
    local file_index
    file_index="$(yq ".packages[$package_index].directories[$dir_index].files | length" "$LIST_FILE")"
    yq -i ".packages[$package_index].directories[$dir_index].files[$file_index].target_dir = \"$target_dir\"" "$LIST_FILE"
    yq -i ".packages[$package_index].directories[$dir_index].files[$file_index].name = \"$filename\"" "$LIST_FILE"
    echo "Added: [$package] $target_dir/$filename."
}

# Remove file
remove() {
    local file="$1"
    file=$(to_absolute_path "$file")

    local target_dir
    target_dir=$(dirname "$file")
    local filename
    filename=$(basename "$file")

    target_dir=$(convert_home_dir_to_home_env "$target_dir")

    # If file isn't exists.
    if [ "$(yq ".packages[].directories[].files[] | select(.target_dir == \"$target_dir\" and .name == \"$filename\")" "$LIST_FILE")" == '' ]; then
        echo "File not exists: $target_dir/$filename."
        return
    fi

    # Get file information from list file
    local package
    package="$(yq ".packages[].directories[].files[] | select(.target_dir == \"$target_dir\" and .name == \"$filename\") | parent(4) | .name" "$LIST_FILE")"
    local directory
    directory="$(yq ".packages[].directories[].files[] | select(.target_dir == \"$target_dir\" and .name == \"$filename\") | parent(2) | .path" "$LIST_FILE")"

    # Remove file
    yq -i "del(.packages[].directories[].files[] | select(.target_dir == \"$target_dir\" and .name == \"$filename\"))" "$LIST_FILE"

    # echo "$(yq ".packages[] | select(.name == \"$package\") | .directories[] | select(.path == \"$directory\") | .files | length" "$LIST_FILE")"
    # echo "$(yq ".packages[] | select(.name == \"$package\") | .directories | length" "$LIST_FILE")"

    # Remove directory if files is empty
    if [ "$(yq ".packages[] | select(.name == \"$package\") | .directories[] | select(.path == \"$directory\") | .files | length" "$LIST_FILE")" -eq 0 ]; then
        yq -i "del(.packages[] | select(.name == \"$package\") | .directories[] | select(.path == \"$directory\"))" "$LIST_FILE"
    fi

    # Remove package if directories is empty
    if [ "$(yq ".packages[] | select(.name == \"$package\") | .directories | length" "$LIST_FILE")" -eq 0 ]; then
        yq -i "del(.packages[] | select(.name == \"$package\"))" "$LIST_FILE"
    fi

    echo "Removed: [$package] $target_dir/$filename."
}

# Add file recursively
add_recursive() {
    local package="$1"
    local directory="$2"
    local target_dir="$3"

    find "$target_dir" -type f -o -type l | while read -r file; do
        add "$package" "$directory" "$file"
    done
}

# Remove file recursively
remove_recursive() {
    local target_dir="$1"

    find "$target_dir" -type f -o -type l | while read -r file; do
        remove "$file"
    done
}

# Sync symbolick link
sync() {
    local pkgs_length
    pkgs_length="$(yq ".packages | length" "$LIST_FILE")"

    local pkg_idx=0
    while [[ $pkg_idx -lt $pkgs_length ]]
    do
        local pkg
        pkg="$(yq ".packages[$pkg_idx].name" "$LIST_FILE")"
        echo "[$pkg]"

        local dirs_length=0
        dirs_length="$(yq ".packages[$pkg_idx].directories | length" "$LIST_FILE")"

        local dir_idx=0
        while [[ $dir_idx -lt $dirs_length ]]
        do
            local dir
            dir="$(yq ".packages[$pkg_idx].directories[$dir_idx].path" "$LIST_FILE")"
            local files_length=0
            files_length="$(yq ".packages[$pkg_idx].directories[$dir_idx].files | length" "$LIST_FILE")"

            local file_idx=0
            while [[ $file_idx -lt $files_length ]]
            do
                local target_dir
                target_dir="$(yq ".packages[$pkg_idx].directories[$dir_idx].files[$file_idx].target_dir" "$LIST_FILE")"
                target_dir="$(convert_home_env_to_home_dir "$target_dir")"
                local file
                file="$(yq ".packages[$pkg_idx].directories[$dir_idx].files[$file_idx].name" "$LIST_FILE")"

                local target
                target="$target_dir/$file"
                echo "target: $target"

                # Skip if not exists
                if [ ! -f "$target" ]; then
                    echo "File not exists: $target"
                    echo "---------------------------------------------------------"
                    _=$(( file_idx++ )) && continue # Temporary
                fi

                local base
                base="$(readlink -e "$target_dir/$file")"

                # Create symbolick link
                local repo
                repo="$DF_ROOT/$pkg/$dir/$file"
                repo="${repo//\/.\//\/}"

                # Create repo directory if not exists
                if [ ! -f "$(dirname "$repo")" ]; then
                    mkdir -p "$(dirname "$repo")"
                fi

                if [ -f "$repo" ] && [ "$base" = "$repo" ]; then
                    echo "Already synchronizing: $repo"
                    echo "---------------------------------------------------------"
                    _=$(( file_idx++ )) && continue # Temporary
                fi

                mv "$base" "$repo"
                ln -fnvs "$repo" "$target"
                echo "---------------------------------------------------------"

                _=$(( file_idx++ ))
            done

            _=$(( dir_idx++ ))
        done

        _=$(( pkg_idx++ ))
    done
}

repo_check() {
    find "$DF_ROOT" -maxdepth 1 -type d  -print0 | while IFS= read -r -d '' dir; do
        if [ "$dir" = "${DF_ROOT}" ]; then
            continue
        fi
        local pkg
        pkg="${dir#"${DF_ROOT}/"}"
        echo "[$pkg]"
        find "$dir" -type f -name '???*' -print0 | while IFS= read -r -d '' file; do
            local rel_path
            rel_path=$(convert_home_dir_to_home_env "$(dirname "$file")")
            echo "path: $rel_path"
            rel_dir=$(dirname "${file#"${DF_ROOT}/$pkg"}")
            echo "dir: $rel_dir"
            filename=$(basename "$file")
            echo "name: $filename"
        done
    done
}

# Main

# Create file if not exists
if [ ! -f "$LIST_FILE" ]; then
    mkdir -p "$(dirname "$LIST_FILE")"
    yq --null-input '{"packages": []}' > "$LIST_FILE"
fi

case "$1" in
    add)
        if [ "$2" = "-r" ]; then
            if [ $# -lt 4 ]; then
                echo "Error: Insufficient arguments for recursive add"
                show_usage
                exit 1
            fi
            if [ $# -eq 4 ]; then
                add_recursive "$3" "." "$4"
            else
                add_recursive "$3" "$4" "$5"
            fi
        elif [ $# -lt 3 ]; then
            echo "Error: Insufficient arguments"
            show_usage
            exit 1
        elif [ $# -eq 3 ]; then
            add "$2" "." "$3"
        else
            add "$2" "$3" "$4"
        fi
        ;;

    rm)
        if [ "$2" = "-r" ]; then
            if [ $# -lt 3 ]; then
                echo "Error: Insufficient arguments for recursive remove"
                show_usage
                exit 1
            fi
            remove_recursive "$3"
        elif [ $# -lt 2 ]; then
            echo "Error: Insufficient arguments"
            show_usage
            exit 1
        else
            remove "$2"
        fi
        ;;

    sync)
        sync
        ;;

    check)
        repo_check
        ;;

    show)
        bat "$LIST_FILE"
        ;;

    edit)
        "${EDITOR:-vi}" "$LIST_FILE"
        ;;

    help)
        show_usage
        ;;

    "--help")
        show_usage
        ;;

    *)
        echo "Error: Invalid command '$1'"
        show_usage
        exit 1
        ;;
esac
